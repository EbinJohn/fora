utils = require('../common/utils')
AppError = require('../common/apperror').AppError

class BaseModel

    constructor: (params) ->
        utils.extend(this, params)
        meta = @constructor.__getMeta__()
        if @_id
            @_id = meta.type._database.ObjectId(@_id)


           
    @get: (params, context, cb) ->
        meta = @__getMeta__()
        @_database.findOne meta.collection, params, (err, result) =>
            cb err, if result then @constructModel(result, meta)



    @getAll: (params, context, cb) ->
        meta = @__getMeta__()
        @_database.find meta.collection, params, (err, cursor) =>
            cursor.toArray (err, items) =>
                cb err, if items?.length then (@constructModel(item, meta) for item in items) else []


    
    @find: (params, fnCursor, context, cb) ->
        meta = @__getMeta__()
        @_database.find meta.collection, params, (err, cursor) =>
            fnCursor cursor
            cursor.toArray (err, items) =>
                cb err, if items?.length then (@constructModel(item, meta) for item in items) else []    



    @getCursor: (params, context, cb) ->
        meta = @__getMeta__()
        @_database.find meta.collection, params, cb


           
    @getById: (id, context, cb) ->
        meta = @__getMeta__()
        @_database.findOne meta.collection, { _id: @_database.ObjectId(id) }, (err, result) =>
            cb err, if result then @constructModel(result, meta)
            
            
            
    @destroyAll: (params, cb) ->
        meta = @__getMeta__()
        if meta.validateMultiRecordOperationParams(params)
            @_database.remove meta.collection, params, (err) =>
                cb?(err)
        else
            cb? new AppError "Call to destroyAll() must pass safety checks on params.", "SAFETY_CHECK_FAILED_IN_DESTROYALL"
            
            
            
    @mergeMeta: (child, parent) ->
        fields = utils.clone(parent.fields)        
        for k,v of child.fields
            fields[k] = v
        meta = utils.clone(parent)
        for k,v of child
            if k isnt 'fields'
                child[k] = v
            else
                child.fields = fields
        meta
                
                
    
    @__getMeta__: (model = @) ->
        try
            meta = model._getMeta()
            meta.validateMultiRecordOperationParams ?= (params) -> 
                false
            meta
        catch e
            utils.dumpError e
        
    
    
    @getLimit: (limit, _default, max) ->
        result = _default
        if limit
            result = limit
            if result > max
                result = max
        result        
        
        
        
    @constructModel: (obj, meta) ->
        if meta.initializer
            meta.initializer obj
        else
            result = {}
            for name, field of meta.fields
                value = obj[name]
                fieldDef = @getFullFieldDefinition field
                if @isCustomClass fieldDef.type
                    if value
                        result[name] = @constructModel value, @__getMeta__(fieldDef.type)
                else
                    if value
                        if fieldDef.type is 'array'
                            arr = []
                            contentType = @getFullFieldDefinition fieldDef.contents
                            if @isCustomClass contentType
                                for item in value
                                    arr.push @constructModel item, @__getMeta__(contentType.type)
                            else
                                arr = value
                            result[name] = arr
                        else
                            result[name] = value    
            if obj._id
                result._id = obj._id
            if meta.typeConstructor
                meta.typeConstructor result
            else
                new meta.type result
     
                
                
    @isCustomClass: (type) ->
        ['string', 'number', 'boolean', 'object', 'array', ''].indexOf(type) is -1                



    @getFullFieldDefinition: (def) ->
        #Convert short hands to full definitions.
        #eg: 'string' means { type: 'string', required: true }
        if typeof(def) isnt "object"
            fieldDef = {
                type: def,
                required: true
            }
        else 
            fieldDef = def

        if fieldDef.autoGenerated and (fieldDef.event is 'created' or fieldDef.event is 'updated')
            fieldDef.type = 'number'
            fieldDef.required = true

        #Required is true unless explicitly set.
        if not fieldDef.required?
            fieldDef.required = true    
            
        fieldDef
        
        
    
    save: (context, cb) =>
        meta = @constructor.__getMeta__()
        
        for fieldName, def of meta.fields
            if def.autoGenerated
                switch def.event
                    when 'created'
                        if not @_id?
                            @[fieldName] = Date.now()    
                    when 'updated'
                        @[fieldName] = Date.now()                            
        
        @validate (err, errors) =>
            if not errors.length
                fnSave = =>
                    @_updateTimestamp = Date.now()                
                    @_shard = if meta.generateShard? then meta.generateShard(@) else "1"
                    
                    if not @_id?
                        if meta.logging?.isLogged
                            event = {}
                            event.type = meta.logging.onInsert
                            event.data = this
                            @constructor._database.insert 'events', event, =>
                        
                        @constructor._database.insert meta.collection, @, (err, r) =>
                            cb? err, r
                    else
                        @constructor._database.update meta.collection, { _id: @_id }, @, (err, r) =>
                            cb? err, @
            
                if @_id and meta.concurrency is 'optimistic'
                    @constructor.getById @_id, context, (err, newPost) =>
                        if newPost._updateTimestamp is @_updateTimestamp
                            fnSave()
                        else
                            cb? new AppError "Update timestamp mismatch. Was #{newPost._updateTimestamp} in saved, #{@_updateTimestamp} in new.", 'OPTIMISTIC_CONCURRENCY_FAIL'
                else
                    fnSave()        
            else
                utils.log "Validation failed for object with id #{@_id} in collection #{meta.collection}."
                for error in errors
                    utils.log error
                utils.log "Error generated at #{Date().toString('yyyy-MM-dd')}."
                cb? new AppError "Model failed validation."


    
    validate: (cb) =>
        meta = @constructor.__getMeta__()
        if not meta.useCustomValidationOnly
            @validateFields meta.fields, (err, errors) =>
                if meta.validate
                    meta.validate.call @, meta.fields, (err, _errors) =>
                        cb err, errors.concat _errors
                else
                    cb err, errors
        else
            if meta.validate?
                meta.validate.call @, meta.fields, (err, errors) =>
                    cb err, errors
            else
                cb null, []
                        
        

    validateFields: (fields, cb) =>
        errors = []

        for fieldName, def of fields
            BaseModel.addError errors, fieldName, @validateField(@[fieldName], fieldName, def)
            
        if cb
            cb null, errors
        else
            errors
            

    validateField: (value, fieldName, def) =>
        errors = []

        if not def.useCustomValidationOnly                
            fieldDef = BaseModel.getFullFieldDefinition(def)
            
            if fieldDef.required and not value?
                errors.push "#{JSON.stringify fieldName} is #{JSON.stringify value}"
                errors.push "#{fieldName} is required."
            
            #Check types.            
            if value
                if fieldDef.type is 'array'
                    for item in value
                        BaseModel.addError errors, fieldName, @validateField(item, "[#{fieldName} item]", fieldDef.contents)
                else
                    #If it is a custom class
                    if (BaseModel.isCustomClass(fieldDef.type) and not (value instanceof fieldDef.type)) or (not BaseModel.isCustomClass(fieldDef.type) and typeof(value) isnt fieldDef.type)
                        errors.push "#{fieldName} is #{JSON.stringify value}"
                        errors.push "#{fieldName} should be a #{fieldDef.type}."

        if def.validate
            BaseModel.addError(errors, fieldName, def.validate.call @)
        
        errors            
        

    
    destroy: (context, cb) =>
        meta = @constructor.__getMeta__()
        @constructor._database.remove meta.collection, { _id: @_id }, (err) =>
            cb? err, @


    
    @addError: (list, fieldName, error) ->
        if error is true
            return list
        if error is false
            list.push "#{fieldName} is invalid."
            return list
        if error instanceof Array
            if error.length > 0
                for item in error
                    if item instanceof Array
                        BaseModel.addError list, fieldName, item
                    else
                        list.push error
            return list
        if error
            list.push error
            return list

exports.BaseModel = BaseModel

