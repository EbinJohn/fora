utils = require('../common/utils')
console = require 'console'
AppError = require('../common/apperror').AppError
Validator = require('./validator').Validator

class BaseModel

    constructor: (params) ->
        utils.extend(this, params)
        meta = @constructor._getMeta()
        if @_id
            @_id = meta.type._database.ObjectId(@_id)


           
    @get: (params, context, cb) ->
        meta = @_getMeta()
        @_database.findOne meta.collection, params, (err, result) =>
            cb err, if result then new meta.type(result)



    @getAll: (params, context, cb) ->
        meta = @_getMeta()
        @_database.find meta.collection, params, (err, cursor) =>
            cursor.toArray (err, items) =>
                cb err, if items?.length then (new meta.type(item) for item in items) else []


    
    @find: (params, fnCursor, context, cb) ->
        meta = @_getMeta()
        @_database.find meta.collection, params, (err, cursor) =>
            fnCursor cursor
            cursor.toArray (err, items) =>
                cb err, if items?.length then (new meta.type(item) for item in items) else []    



    @getCursor: (params, context, cb) ->
        meta = @_getMeta()
        @_database.find meta.collection, params, cb


           
    @getById: (id, context, cb) ->
        meta = @_getMeta()
        @_database.findOne meta.collection, { _id: @_database.ObjectId(id) }, (err, result) =>
            cb err, if result then new meta.type(result)
            
            
            
    @destroyAll: (params, cb) ->
        meta = @_getMeta()
        if meta.validateMultiRecordOperationParams(params)
            @_database.remove meta.collection, params, (err) =>
                cb?(err)
        else
            cb? new AppError "Call to destroyAll() must pass safety checks on params.", "SAFETY_CHECK_FAILED_IN_DESTROYALL"
            
            
            
    @_getMeta: ->
        meta = @_meta
        meta.validateMultiRecordOperationParams ?= (params) -> 
            false
        meta



    @getLimit: (limit, _default, max) ->
        result = _default
        if limit
            result = limit
            if result > max
                result = max
        result        

    
    save: (context, cb) =>
        meta = @constructor._getMeta()
        
        for fieldName, def of meta.fields
            if def.autoGenerated
                switch def.event
                    when 'created'
                        if not @_id?
                            @[fieldName] = Date.now()    
                    when 'updated'
                        @[fieldName] = Date.now()                            
        
        @validate (err, errors) =>
            if not errors.length
                fnSave = =>
                    @_updateTimestamp = Date.now()                
                    @_shard = if meta.generateShard? then meta.generateShard(@) else "1"
                    
                    if not @_id?
                        if meta.logging?.isLogged
                            event = {}
                            event.type = meta.logging.onInsert
                            event.data = this
                            meta.type._database.insert 'events', event, =>
                            
                        meta.type._database.insert meta.collection, @, (err, r) =>
                            cb? err, r
                    else
                        meta.type._database.update meta.collection, { _id: @_id }, @, (err, r) =>
                            cb? err, @
            
                if @_id and meta.concurrency is 'optimistic'
                    @constructor.getById @_id, context, (err, newPost) =>
                        if newPost._updateTimestamp is @_updateTimestamp
                            fnSave()
                        else
                            cb? new AppError "Update timestamp mismatch. Was #{newPost._updateTimestamp} in saved, #{@_updateTimestamp} in new.", 'OPTIMISTIC_CONCURRENCY_FAIL'
                else
                    fnSave()        
            else
                console.log "Validation failed for object with id #{@_id} in collection #{meta.collection}."
                for error in validation.errors
                    console.log error
                console.log "Error generated at #{Date().toString('yyyy-MM-dd')}."
                cb? new AppError "Model failed validation."


    
    validate: (cb) =>
        errors = []
        meta = @constructor._getMeta()
        (meta.validate ? @validateFields).call @, meta.fields, (err, errors) =>
            cb err, errors


        
    validateFields: (model, fields, cb) =>
        errors = []        
        new Validator().validate model, fields, cb


    
    destroy: (context, cb) =>
        meta = @constructor._getMeta()
        meta.type._database.remove meta.collection, { _id: @_id }, (err) =>
            cb? err, @

    
    
    summarize: (fields) =>
        result = {}
        
        if fields
            for field in fields
                result[field] = this[field]

        result



exports.BaseModel = BaseModel

