
utils = require '../common/utils'
AppError = require('../common/apperror').AppError
BaseModel = require('./basemodel').BaseModel
defer = require('../common/deferred').defer
hasher = require('../common/hasher').hasher

class User extends BaseModel

    @describeModel: ->
        {
            type: User,
            collection: 'users',
            fields: {
                username: 'string',
                name: 'string',
                location: 'string',
                picture: 'string',
                thumbnail: 'string',
                email: 'string',
                accessToken: { type: 'string', required: false },
                lastLogin: 'number',
                assetPath: 'string',
                following: { type: 'array', contents: @getModels().User.Summary, validate: -> x.validate() for x in @following },
                subscriptions: { type: 'array', contents: @getModels().Forum.Summary, validate: -> x.validate() for x in @subscriptions },            
                about: { type: 'string', required: false },
                createdAt: { autoGenerated: true, event: 'created' },
                updatedAt: { autoGenerated: true, event: 'updated' }            
            },
            logging: {
                isLogged: true,
                onInsert: 'NEW_USER'
            }
        }
       

   
    #Called from controllers when a new session is created.
    @createOrUpdate: (userDetails, authInfo, context, db) ->
        switch authInfo.type
            when 'builtin'
                @createBuiltinUser userDetails, authInfo.password, context, db
            when 'twitter'
                @createOrUpdateTwitterUser userDetails, authInfo, context, db
            #when 'facebook'
            

    @createBuiltinUser: (userDetails, password, context, db) ->
        deferred = defer()
        @getModels().Credentials.get({ username: userDetails.username }, context, db)
            .then (credentials) =>
                if not credentials
                    user = new User { username: userDetails.username }                    

                    hasher { plaintext: password }, (err, result) =>
                        # Save as hex strings
                        salt = result.salt.toString 'hex'
                        hash = result.key.toString 'hex'

                        credentials = new (@getModels().Credentials) {
                            username: userDetails.username,
                            token: utils.uniqueId(24), 
                            builtin: { method: 'PBKDF2', hash, salt }
                        }

                        user.updateFrom userDetails                        
                        user.save(context, db)
                            .then (user) =>            
                                credentials.userid = user._id.toString()
                                credentials.save(context, db)
                                    .then (credentials) =>
                                        deferred.resolve { user, token: credentials.token }
                else
                    deferred.reject new AppError "User #{userDetails.username} already exists.", "USER_ALREADY_EXISTS"
        deferred.promise


    @createOrUpdateTwitterUser: (userDetails, authInfo, context, db) ->
        deferred = defer()
        @getModels().Credentials.get({ twitter: userDetails.username }, context, db)
            .then (credentials) =>
                if not credentials
                    user = new User { username: userDetails.username }                    
                    credentials = new (@getModels().Credentials) {
                        username: userDetails.username,
                        token: utils.uniqueId(24), 
                        twitter: { username: authInfo.username }
                    }            

                    user.updateFrom userDetails                        

                    user.save(context, db)
                        .then (user) =>            
                            credentials.userid = user._id.toString()
                            credentials.save(context, db)
                                .then (credentials) =>
                                    deferred.resolve { user, token: credentials.token }

                else
                    @getModels().User.get({ username: credentials.username }, context, db)
                        .then (user) =>
                            user.updateFrom userDetails
                            user.save(context, db)
                                .then (user) =>
                                    deferred.resolve { user, token: credentials.token }
        deferred.promise


  
    #Todo. Token Expiry.   
    @authenticateBuiltinUser: (username, password, context, db) ->
        deferred = defer()
        @getModels().Credentials.get({ username }, context, db)
            .then (credentials) =>
                if credentials.builtin
                    bcrypt.compare password, credentials.builtin.hash, (err, res) ->
                        if res
                            User.get({ username }, context, db)
                                .then (user) =>
                                    deferred.resolve { user, token: credentials.token }
                        else
                            deferred.resolve {}
                 else
                    deferred.reject new AppError "User #{username} does not have an account.", "MISSING_CREDENTIAL_TYPE"
        deferred.promise             
        


    @getUserWithToken: (token, context, db) ->
        @getModels().Credentials.get({ token }, context, db)
            .then (credentials) =>
                User.get({ username: credentials.username }, context, db)

                                                        
    
    @getByUsername: (username, context, db) ->
        User.get({ username }, context, db)



    constructor: (params) ->
        super
        @about ?= ''
        @karma ?= 1
        @preferences ?= {}
        @following ?= []
        @followerCount ?= []
        @subscriptions ?= []
        @totalItemCount ?= 0



    getUrl: =>
        "/users/@#{username}"



    save: (context, db) =>
        if not @_id
            super(context, db)
                .then (user) =>               
                    userinfo = new (@getModels().UserInfo) {
                        userid: user._id.toString(),
                        username: user.username                        
                    }  
                    userinfo.save(context, db)
                        .then =>
                            user
        else
            super        
            
            
            
    updateFrom: (userDetails) =>
        @name = userDetails.name
        @location = userDetails.location
        @picture = userDetails.picture
        @thumbnail = userDetails.thumbnail
        @tile = userDetails.tile ? '/images/collection-tile.png'
        @email = userDetails.email ? 'unknown@foraproject.org'
        @lastLogin = Date.now()
        @preferences = { canEmail: true }
        @about = userDetails.about

        #Allow dev scripts to set assetPath for initial set of users, so that it stays the same.
        if userDetails.createdVia is 'internal' and userDetails.assetPath
            @assetPath = userDetails.assetPath    
        else
            createdAt = new Date
            @assetPath = "/pub/assetpaths/#{createdAt.getFullYear()}-#{createdAt.getMonth()+1}-#{createdAt.getDate()}"        



    summarize: =>        
       new Summary {
            id: @_id.toString()
            username: @username
            name: @name,
            @assetPath
        }

    
class Summary extends BaseModel    
    @describeModel: ->
        {
            type: Summary,
            fields: {
                id: 'string',
                username: 'string',
                name: 'string',
                assetPath: 'string'
            }
        }
            
User.Summary = Summary                
exports.User = User
